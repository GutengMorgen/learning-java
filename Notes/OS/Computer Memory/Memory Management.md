# Static and Dynamic Loading
**Loading a process into the main memory is done by a loader.** 

There are two different types of loading:

## Static Loading
**Static Loading is basically loading the entire program into a fixed address.** It requires more memory space.

## Dynamic Loading
**The entire program and all data of a process must be in physical memory for the process to execute.** So, the size of a process is limited to the size of physical memory. To gain proper memory utilization, dynamic loading is used. **In dynamic loading, a routine is not loaded until it is called.** All routines are residing on disk in a relocatable load format. **One of the advantages of dynamic loading is that the unused routine is never loaded.** This loading is useful when a large amount of code is needed to handle it efficiently.

# Static and Dynamic Linking
To perform a linking task a linker is used. **A linker is a program that takes one or more object files generated by a compiler and combines them into a single executable file.** 

## Static Linking
**In static linking, the linker combines all necessary program modules into a single executable program.** So there is no runtime dependency. Some operating systems support only static linking, in which system language libraries are treated like any other object module.

## Dynamic Linking
The basic concept of dynamic linking is similar to dynamic loading. **In dynamic linking, “Stub” is included for each appropriate library routine reference.** A stub is a small piece of code. **When the stub is executed, it checks whether the needed routine is already in memory or not. If not available then the program loads the routine into memory.**

# Swapping
When a process is executed it must have resided in memory. **Swapping is a process of swapping a process temporarily into a secondary memory from the main memory**, which is fast compared to secondary memory. 

A swapping allows more processes to be run and can be fit into memory at one time. The main part of swapping is **transferred time and the total time is directly proportional to the amount of memory swapped.** 

The concept of swapping has divided into two more concepts: Swap-in(aka. roll-in) and Swap-out(aka. roll-out).

- Swap-out is a method of removing a process from RAM and adding it to the hard disk.
- Swap-in is a method of removing a program from a hard disk and putting it back into the main memory or RAM.

*if a higher priority process arrives and wants service, the memory manager can swap out the lower priority process and then load and execute the higher priority process.* After finishing higher priority work, the lower priority process swapped back in memory and continued to the execution process.

![figure 1](https://media.geeksforgeeks.org/wp-content/uploads/20221116104533/2white-660x441.png)

# Fragmentation
Is defined as **when the process is loaded and removed after execution from memory, it creates a small free hole.** These holes can not be assigned to new processes because holes are not combined or do not fulfill the memory requirement of the process.

To achieve a degree of multiprogramming, we must reduce the waste of memory or fragmentation problems. In the operating systems two types of fragmentation:

1. **Internal fragmentation:** Occurs when memory blocks are allocated to the process more than their requested size. Due to this some unused space is left over and creating an internal fragmentation problem.
	- **Example:** Suppose there is a fixed partitioning used for memory allocation and the different sizes of blocks 3MB, 6MB, and 7MB space in memory. Now a new process p4 of size 2MB comes and demands a block of memory. It gets a memory block of 3MB but 1MB block of memory is a waste, and it can not be allocated to other processes too. This is called internal fragmentation.
2. **External fragmentation:** In External Fragmentation, we have a free memory block, but we can not assign it to a process because blocks are not contiguous.
	- **Example:** Suppose (consider the above example) three processes p1, p2, and p3 come with sizes 2MB, 4MB, and 7MB respectively. Now they get memory blocks of size 3MB, 6MB, and 7MB allocated respectively. After allocating the process p1 process and the p2 process left 1MB and 2MB. Suppose a new process p4 comes and demands a 3MB block of memory, which is available, but we can not assign it because free memory space is not contiguous.  This is called external fragmentation.

Both the first-fit and best-fit systems for memory allocation are affected by external fragmentation. To overcome the external fragmentation problem Compaction is used. In the compaction technique, all free memory space combines and makes one large block. So, this space can be used by other processes effectively.

Another possible solution to the external fragmentation is to allow the logical address space of the processes to be noncontiguous, thus permitting a process to be allocated physical memory wherever the latter is available.

# What?
- what is a fixed address?
- what is a linker?
- what is a stub?
- what is memory swapped?
- 


# Resources
- [guru99](https://www.guru99.com/os-memory-management.html)
- [geeksforgeeks](https://www.geeksforgeeks.org/memory-management-in-operating-system/)
- [runestone](https://runestone.academy/ns/books/published/welcomecs/OperatingSystems/VirtualMemory.html)
- [duckduckgo](https://duckduckgo.com/?q=memory+management+in+operating+system&t=brave&iax=images&ia=images&iai=https%3A%2F%2Fd3e8mc9t3dqxs7.cloudfront.net%2Fwp-content%2Fuploads%2Fsites%2F11%2F2020%2F05%2FMemory-Management-F2-768x414.png)
- [javatpoint](https://www.javatpoint.com/swapping-in-operating-system)
- 